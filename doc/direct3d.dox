/**
\page d3d

The SGUI library can create windows with a Direct3D&reg; device/context the
same way it can create windows with an OpenGL&reg; context (see \ref ogl).
The Windows&reg; backend directly supports Direct3D&reg; 9 and 11 (on the
later, feature level 9.0 to 11.0). Because Direct3D&reg; requires access to a
lot of data structures created with the context, the declarations of the
underlying context structures are exposed via the headers \ref sgui_d3d9.h and
\ref sgui_d3d11.h that have to be included in the application as no other
public header includes them.

The library itself does \a not \a link \a against \a any \a Direct3D&reg;
\a library and can be used on older versions of Windows&reg;, where the
required DLLs are not available, without recompilation. The SGUI Windows&reg;
backend internally tries to load the libraries at runtime when requested.
Since all D3D objects are created from the objects in the \ref sgui_context,
an application using SGUI also doesn't have to link against Direct3D&reg;
libraries.

Samples on how all of this is done are provided in the \a extras directory and
pointed out below.

Similar to \ref ogl, the subview widget can also create a sub window with a
Direct3D&reg 9 or 11 device/context.

It is adviceable to also look at the \ref ogl page for comparison as they
share a lot of concepts and API calls. Because legacy GL requires a lower
setup overhead to get a triangle drawn, the OpenGL&reg; samples are also less
cluttered, shorter and simpler.

\section managedd3d Creating an Automatically Managed Direct3D&reg; Window

The code for a small example program can be found in the files \ref d3d9_0.c
for Direct3D&reg; 9 and \ref d3d11_0.c for Direct3D&reg; 11. The programs work
in ways similar to \ref gl0.c but use Direct3D&reg; 9 and 11 respectively. The
symbolic constants \ref SGUI_DIRECT3D_9 and \ref SGUI_DIRECT3D_11 are used to
request the API versions from the backend.

The sample programs create a Direct3D&reg; window, along with resources
required to draw a triangle. The \ref SGUI_EXPOSE_EVENT generated by the
window when it is asked by the OS to redraw itself is connected to a callback
that renderes the actual frame.

The function \ref sgui_window_swap_buffers is used in both samples. The D3D9
implementation calls \a Present on the device, the D3D11 implementation
calls \a Present on the swapchain.

\section manuald3d Creating a Manually Managed Direct3D&reg; Window

The code for small smple programs can be found in the files \ref d3d9_1.c and
\ref d3d11_1.c which work in ways similar to \ref gl1.c, except for using D3D9
and D3D11 respectively.

After creating a window and the neccessary resources to draw a triangle, the
sample programs enter a manual main loop using the non-blocking
\ref sgui_main_loop_step to fetch and process window system messages (if any)
at every iteration. Drawing is done directly in the loop body at maximum
framerate.


\section subd3d Creating a Direct3D&reg; Sub Window

It is also possible to create a sub window with a Direct3D&reg; device/context
as a small drawing area inside of a window containing normal widgets. Sub
windows can be created by specifying a parent window pointer in the
\ref sgui_window_description structure, used by \ref sgui_window_create_desc
function.

To make things easier, there is a \ref sgui_subview wiget that takes care of
managing a sub window, making sure it sticks to the widget coordinate system
and interacts propperly with parent widgets. The sub view widget exposes
normal widget functions and calls a callback whenever the underlying window
needs a redraw.

Examples on how to use the subview widget with Direct3D&reg; can be found in
\ref d3d9_2.c and \ref d3d11_2.c.


\section thread3d Direct3D&reg; Sub Windows With Drawing Threads

If not creating a sub window manually, the function
\ref sgui_subview_get_window can be used to obtain a pointer to the window
object created by an \ref sgui_subview widget.

The context object of the returned window can be obtained by calling
\ref sgui_window_get_context.

The data fields from the context object can then be used in a dedicated
drawing thread that redraws the window content in a loop at maximum frame
rate, calling \ref sgui_window_swap_buffers after every iteration to swap
the front and back buffer.

Example applications that do this can be found in \ref d3d9_3.c and
\ref d3d11_3.c.


\section d3dint Getting the Internals

A pointer to the underlying \ref sgui_context object of a window is obtained
by calling \ref sgui_window_get_context on the window pointer. The context
pointer returned can then be casted to either \ref sgui_d3d9_context
(which can be found in \ref sgui_d3d9.h) or \ref sgui_d3d11_context
(which can be found in \ref sgui_d3d11.h).

The \ref sgui_d3d9_context structure contains a pointer to an
\a IDirect3DDevice9 and the \a D3DPRESENT_PARAMETERS struct.

The \ref sgui_d3d11_context structure contains a pointers to the
\a IDXGISwapChain, the \a ID3D11Device, the \a ID3D11DeviceContext, as well
as to the backbuffer view (\a ID3D11RenderTargetView), if requested at window
creation the depth/stencil texture (\a ID3D11Texture2D) and view
(\a ID3D11DepthStencilView). The later two are NULL if not requested
during window creation.


\section d3dsize Window Resizing, Present Parameter Changes and Lost Devices

Changing the size of a window or vsync settings under Direct3D&reg; 9 requires
a \a device \a reset which will cause the application to lose all GPU buffers.
Similarly, a D3D9 device can enter a \a LOST state under certain conditions
which also requires a device reset.

Before calling the \a Reset method on the device, however, all un-managed
resources have to be released. Since the SGUI library has no knowledge of any
resources created by the device, it only updates the present parameters, but
leaves the task of resetting the device to the user.

At the end of the message processing function, the devices of all
Direct3D&reg; 9 windows are checked for their "cooperative level". If a device
entered a lost state, an \ref SGUI_D3D9_DEVICE_LOST event is generated.

Since Direct3D&reg; 11 has a way saner API, SGUI can fully manage
window resizes and other parameter changes. When the window size changes
(either by calling the resize function or by the user dragging the window
edges around), the swapchain back buffer is resized, along with the
depth/stencil texture created for the main frame buffer. The frame buffer and
depth/stencil view objects are also recreated. If the main frame buffer was
bound before resizing, it is rebound after resizing and the viewport
dimensions set to the entire window size.

\note In order for any of this to work, the backend must be able to destroy
      the buffers with a single Release call, i.e. you \a must \a not do
      anything that increases the reference count of those objects. And not
      keep pointers around to the objects. Use indirection through the context
      structure instead.
*/
